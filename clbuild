#!/bin/bash
#
# Script to update/install the latest versions of all the most
# important Common Lisp projects. Uses SBCL but otherwise tries to be
# somewhat independent of your local environment.
#
# Intended to quickly bootstrap a working development environment for
# Lisp free software hackers.
#
# Idea from jhbuild by James Henstridge (a Gnome hacker).
#
# Contributors:
#   Luke Gorrie <luke@member.fsf.org>
#   Anthony Chaumas-Pellet <achaumas@wispery.info>
#   Christophe Rhodes <csr21@cantab.net>
#   David Lichteblau <david@lichteblau.com>
#   Eric Marsden <eric.marsden@free.fr>
#   Andreas Fuchs <asf@boinkor.net>

set -e

if [ "$CLNET_USER" == "" ]; then
    CLNET_USER=:pserver:anonymous:anonymous
fi
export CLNET_USER

self="$0"
while test -h "$self"; do
	self=`readlink "$self"`
done
BASE="$(cd "$(dirname $self)" && pwd)"
system_dir="$BASE/systems"
source_dir="$BASE/source"
target_dir="$BASE/target"

if test x`uname -o 2>/dev/null` = xCygwin; then
	windowsp=1
else
	windowsp=""
fi

source "$BASE/clbuild.conf.default"
if test -f "$BASE/clbuild.conf"; then
    source "$BASE/clbuild.conf"
fi
# Fix up pathnames
make_absolute_pn() {
	if [ -n "$1" ] ; then
		(cd "$BASE"
		echo "$(cd "$(dirname "$1")" ; pwd)/$(basename "$1")")
	fi
}
case $UPDATE_SCRIPT in
    update_project)
	# okay, new name
	;;
    update.sh)
	# old name
	UPDATE_SCRIPT=update_project
	;;
    *)
	# do will still want this?
	UPDATE_SCRIPT="$(make_absolute_pn "$UPDATE_SCRIPT")"
	;;
esac
USER_INIT="$(make_absolute_pn "$USER_INIT")"

if test -n "$windowsp" -a x$USER_INIT = x/dev/null; then
	USER_INIT=NUL
fi

# CLIM configuration
case x$CLIM_BACKEND in
    xgraphic-forms|xgtkairo|xbeagle)
        EXTRA_CLIM_FEATURES="(pushnew :clim-$CLIM_BACKEND *features*)"
	maybe_load_clx="nil"
        ;;
    x|xclx)
        EXTRA_CLIM_FEATURES="nil"
	maybe_load_clx="(unless (find-package :xlib) (asdf:operate 'asdf:load-op :clx))"
        ;;
    *)
        echo "invalid $CLIM_BACKEND, see clbuild.conf.default for examples." 1>&2
        exit 1
        ;;
esac

if test -n "$windowsp"; then
	system_namestring="`cygpath -m $system_dir`/"
	source_namestring="`cygpath -m $source_dir`/"
	target_namestring="`cygpath -m $target_dir`/"
	self="c:/cygwin/bin/bash $self"
else
	system_namestring="$system_dir/"
	source_namestring="$source_dir/"
	target_namestring="$target_dir/"
fi
set_central_registry="(setq asdf:*central-registry* '(#p\"${system_namestring}\"))"

if [ ! -z $CCL ]; then
    #
    # OpenMCL
    #
    lisp=$CCL

    noinform="-Q"
    end_toplevel_options="" #fixme
    quit="(ccl:quit)"
    eval="--eval"
    require_asdf="(require :asdf)"
    core_option="-I"

    if test x"$USER_INIT" = x/dev/null; then
	# -l /dev/null does not work
	common_options="-n"
    elif test -n "$USER_INIT"; then
	common_options="-n -l $USER_INIT"
    else
	common_options=""
    fi

    # fixme: this doesn't quite match the SBCL version yet:
    build_options="$noinform --batch $common_options"
    run_options="--batch $common_options"
elif [ ! -z $CLISP ]; then
    #
    # CLISP
    #
    echo '*** Using CLISP.  Please note that CLISP support is not complete.'
    lisp="$CLISP -repl"

    noinform="" #fixme
    end_toplevel_options="" #fixme
    quit="(ext:quit)"
    eval="-x"
    require_asdf="(load \"$BASE/source/asdf-for-clisp/asdf.lisp\")"
    core_option="-M"

    if test -n "$USER_INIT"; then
	common_options="-norc -i $USER_INIT"
    else
	common_options=""
    fi

    build_options="-on-error exit $common_options"
    run_options="-on-error exit $common_options"

    if test -d "$BASE/source/asdf-for-clisp"; then
	echo "*** asdf checkout found"
	echo
    else
	echo "NEW checking out asdf for use with clisp"
	(cd "$BASE/source" && cvs -d ${SF_USER}@sbcl.cvs.sourceforge.net:/cvsroot/sbcl co -d asdf-for-clisp sbcl/contrib/asdf)
    fi
else
    #
    # SBCL
    #
    if [ ! -z "$SBCL" ]; then
	lisp=$SBCL
    elif [ -x ${target_dir}/bin/sbcl ]; then
	export SBCL_HOME=${target_namestring}lib/sbcl/
	lisp="${target_dir}/bin/sbcl"
	if ! test -f "$BASE"/monster.core; then
	    lisp="$lisp --core ${target_namestring}lib/sbcl/sbcl.core"
	fi
    else
	lisp=sbcl
    fi

    noinform="--noinform"
    end_toplevel_options="--end-toplevel-options"
    quit="(sb-ext:quit)"
    eval="--eval"
    require_asdf="(require :asdf)"
    core_option="--core"

    if test -n "$USER_INIT"; then
	common_options="--userinit $USER_INIT"
    else
	common_options=""
    fi

    build_options="$noinform --noprint --disable-debugger $common_options"
    run_options="--disable-debugger $common_options"
fi

[ -d "$system_dir" ] || mkdir "$system_dir"
[ -d "$source_dir" ] || mkdir "$source_dir"
[ -d "$target_dir" ] || mkdir "$target_dir"

clbuild_lisp() {
    ${lisp} $common_options \
	$eval "$require_asdf" \
	$eval "$set_central_registry" \
	$eval "$EXTRA_CLIM_FEATURES" \
	"$@"
}

lisp_trampoline() {
    # Start the Lisp with user arguments.  For SBCL, we can do that using
    # --end-toplevel-options.  For other Lisps, go through a temporary
    # file.

    options="$1"
    shift

    if test -n "$end_toplevel_options"; then
	${lisp} \
	    $options \
	    $eval "$require_asdf" \
	    $eval "$set_central_registry" \
	    $eval "$EXTRA_CLIM_FEATURES" \
	    $eval "(load \"$BASE/clbuild.lisp\")" \
	    $end_toplevel_options \
	    "$@"
    else
        TMPDIR=`mktemp -d /tmp/clbuild.XXXXXXXXXX`
	export TMPDIR

        cleanup() {
            rm -rf $TMPDIR
        }
        trap cleanup exit

	while test -n "$1"; do
	    # fixme: whitespacea
	    echo $1 >>$TMPDIR/args
	    shift
	done

	${lisp} \
	    $options \
	    $eval "$require_asdf" \
	    $eval "$set_central_registry" \
	    $eval "$EXTRA_CLIM_FEATURES" \
	    $eval "(defparameter cl-user::*clbuild-args* \"$TMPDIR/args\")" \
	    $eval "(load \"$BASE/clbuild.lisp\")"
    fi
}

start_application() {
    lisp_trampoline "$noinform $run_options" "$@"
}

recompile() {
	if test x"$1" = x--dump; then
	    dump="--dump t"
	    shift
	else
	    dump=""
	fi

	concatenated_args="$@"
	if test -z "$concatenated_args"; then
	    concatenated_args="$main_projects"
	fi

	cd "$BASE"
	lisp_trampoline "$build_options" \
	    recompile-systems \
	    $dump \
	    "$concatenated_args"
}

count_systems() {
	n_asd=`ls -1 "$system_dir"/*.asd | wc -l`
	echo "$n_asd system definition files registered"
}

blank_line="                                                                  "
tail_last() {
    if tty 0>&1 >/dev/null; then
	while read line; do
	    echo -e '\r\c'
	    echo -n "$blank_line"
	    echo -e '\r\c'
	    echo -n $line | cut -b 1-65 | tr -d '\n'
	done
	echo -e '\r\c'
	echo -n "$blank_line"
	echo -e '\r\c'
    else
	while read line; do
	    echo $line
	done
    fi
}

dribble_get() {
    label="$1"
    name="$2"

    if test -d `echo ${name}*/ | awk '{print $1;}'`; then
	echo -n "UPDATE "
    else
	echo -n "NEW "
    fi
    echo "$label $name"
}

dry_run_ok() {
   if test -n "$dry_run"; then
       echo "OK: $1"
   fi
}

dry_run_missing() {
   if test -n "$dry_run"; then
       echo "MISSING: $1"
   fi
}

get_darcs() {
    name="$1"
    url="$2"

    if [ -d $name ]; then
	actual="`cat $name/_darcs/prefs/defaultrepo`"
	if test "x$actual" = "x$url"; then
	    dry_run_ok $1
	else
	    echo "MISMATCH: $1 was installed from $actual, current is $url"
	fi
    else
	dry_run_missing $1
    fi
    if test -n "$dry_run"; then
	exit 0
    fi

    # don't use tail_last, since darcs already has this kind of progress bar
    if [ -d $name ]; then
	dribble_get "darcs pull" $name
	(
	    cd $name
	    if ! test -d _darcs; then
		echo ERROR: not a darcs repository
		exit 1
	    fi
	    darcs pull --all
	    )
    else
	dribble_get "darcs get" $name
	darcs get $url $name
    fi
}

get_git() {
    name="$1"
    url="$2"

    if [ -d $name ]; then
	actual="`cd $name && git config --get remote.origin.url`"
	if test "x$actual" = "x$url"; then
	    dry_run_ok $1
	else
	    echo "MISMATCH: $1 was installed from $actual, current is $url"
	fi
    else
	dry_run_missing $1
    fi
    if test -n "$dry_run"; then
	exit 0
    fi

    if [ -d $name ]; then
	dribble_get "git pull" $name
	(
	    cd $name
	    if ! test -d .git; then
		echo ERROR: not a git repository
		exit 1
	    fi
	    git pull
	    )
    else
	dribble_get "git clone" $name
	git clone $url $name
    fi
}

get_svn() {
    name="$1"
    url="$2"

    if [ -d $name ]; then
	actual="`cd $name && svn info | grep ^URL: | awk '{print $2;}'`"
	if test "x$actual" = "x$url"; then
	    dry_run_ok $1
	else
	    echo "MISMATCH: $1 was installed from $actual, current is $url"
	fi
    else
	dry_run_missing $1
    fi
    if test -n "$dry_run"; then
	exit 0
    fi

    dribble_get "svn co" $name

    svn co $url $name | tail_last
}

get_cvs_aux() {
    module="$1"
    repository="$2"
    target_directory="$3"

    if [ -d $module ]; then
	actual="`cat $module/CVS/Root`"
	if test "x$actual" = "x$repository"; then
	    dry_run_ok $1
	else
	    echo "MISMATCH: $1 was installed from $actual, current is $repository"
	fi
    else
	dry_run_missing $1
    fi
    if test -n "$dry_run"; then
	exit 0
    fi

    dribble_get "cvs co" $module

    cvs -d $repository co ${3+-d "$3"} $module | tail_last
}

get_cvs_full() {
    get_cvs_aux $3 $2 $1
}

get_tarball() {
    name="$1"
    url="$2"
    flags="${3:-z}"

    echo "Warning: Using deprecated method get_tarball."

    if test -n "$dry_run"; then
	if ls -d ${name}* >/dev/null; then
	    directories="`ls -d ${name}*`"
	    echo "TARBALL: $directories installed from a tarball, cannot check"
	else
	    dry_run_missing $1
	fi
	exit 0
    fi

    tmp=$TMPDIR/${name}.tar.gz

    dribble_get wget $name

    # We used to delete old directories completely here.  Unfortunately,
    # that can easily lead to loss of changes, a problem all the VC checkout
    # method do not have to the extent.  Save all old data instead.  Users
    # can delete the resulting backup directories easily enough themselves.
    if ls ${name}* >/dev/null; then
	echo got here
	backup=`mktemp -d backup_${name}_XXXXXXXXXX`
	mv ${name}* "$backup/"
    fi
    wget \
	--no-check-certificate \
	--progress=dot \
	-O "$tmp" \
	$url \
	2>&1 | tail_last
    tar v${flags}xf "$tmp" | tail_last
    rm "$tmp"
}

get_svn_clnet() {
    name="$1"
    path="$2"

    get_svn $name svn://common-lisp.net/project/$name/svn/$2
}

get_cvs_clnet() {
    module="$1"
    project="${2:-$1}"

    get_cvs_aux $module ${CLNET_USER}@common-lisp.net:/project/$project/cvsroot
}

get_cvs_sfnet() {
    module="$1"
    project="${2:-$1}"

    get_cvs_aux $module ${SF_USER}@$project.cvs.sourceforge.net:/cvsroot/$project
}

get_ediware() {
    get_darcs $1 http://common-lisp.net/~loliveira/ediware/$1
}

get_clbuild_mirror() {
    get_darcs $1 http://common-lisp.net/project/clbuild/mirror/$1
}

get_lichteblau_com() {
    get_git $1 http://www.lichteblau.com/git/$1.git
}

get_b9_com() {
    get_git $1 http://git.b9.com/$1.git
}

get_xach_com() {
    get_git $1 http://git.xach.com/$1.git
}

get_tarball_bz2() {
    get_tarball "$1" "$2" j
}

update_project() {
    if test x$1 = x--dry-run; then
	shift
	dry_run=1
    else
	unset dry_run
    fi
    export dry_run

    if test $# -ne 1; then
	exec 1>&2
	echo error: invalid number of arguments
	echo usage: ... update [--dry-run] PROJECT_NAME
	exit 1
    fi

    if ! grep -h "^$1 " "$BASE/projects" "$BASE/wnpp-projects" >/dev/null; then
       echo Error: cannot download unknown project $1
       rm "$BASE/.clbuild-resume"
       exit 1
    fi
    found=`grep -h "^$1 " "$BASE/projects" "$BASE/wnpp-projects" | cut -d\# -f1`
    update_project_2 $found
}

update_project_2() {
    name="$1"
    action="$2"
    shift
    shift
    ( $action $name "$@" )
}

update() {
    if test -n "$clbuild_resume"; then
	if test $# -gt 0; then
	    echo "error: --resume conflicts with arguments" 1>&2
	    exit 1
	fi
	previous=`cat "$BASE/.clbuild-resume"`
	CLBUILD_DEPENDENCIES=no update_1 $previous
    elif test $# -gt 0; then
	rm -f $source_dir/*/.clbuild-skip-update
	update_1 $*
    else
	exec 1>&2
	echo "Error: arguments expected"
	echo "Usage:"
	echo "  clbuild update PROJECT1 PROJECT2 PROJECT3...  # only these"
	echo "  clbuild update --resume            # resume interrupted update"
	echo "  clbuild update --main-projects     # all in projects file"
	echo "  clbuild update --wnpp-projects     # all in wnpp-projects file"
	echo "  clbuild update --all-projects      # both files"
	exit 1
    fi
}

update_1() {
        touch "$BASE"/.core-is-stale

        TMPDIR=`mktemp -d /tmp/clbuild.XXXXXXXXXX`
	export TMPDIR

        cleanup() {
	    if test -f "$BASE/.clbuild-resume"; then
		exec 1>&2
		echo
		echo error: update was interrupted.
		echo 'Use "clbuild update --resume" to retry.  (See also "clbuild skip PROJECT").'
	    fi
            rm -rf $TMPDIR
        }
        trap cleanup exit

	cd "$source_dir"

	touch $TMPDIR/dependencies0
	while test $# -ge 1; do
	    echo $1 >>$TMPDIR/arguments0
	    if grep "^$1 " ../dependencies >/dev/null; then
		found=`grep "^$1 " ../dependencies`
		for x in $found; do
		    echo $x >>$TMPDIR/dependencies0
		done
	    else
		echo $1 >>$TMPDIR/dependencies0
		echo "warning: no dependencies for $1 found" 1>&2
	    fi
	    shift
	done
	sort <$TMPDIR/arguments0 | uniq >$TMPDIR/arguments
	sort <$TMPDIR/dependencies0 | uniq >$TMPDIR/dependencies

	if ! cmp $TMPDIR/arguments $TMPDIR/dependencies >/dev/null; then
	    case "$CLBUILD_DEPENDENCIES" in
		ask)
		    extra=`diff $TMPDIR/arguments $TMPDIR/dependencies | grep '^>' | cut -d' ' -f2 | xargs echo`
		    echo "The following extra dependencies were found: $extra"
		    echo -n "include dependencies in update? (Y/n)"
		    read reply
		    case _"$reply" in
			_Y|_y|_)
			    ;;
			_n)
			    mv $TMPDIR/arguments $TMPDIR/dependencies
			    ;;
			*)
			    echo Invalid reply
			    exit 1
			    ;;
		    esac
		    ;;
		yes)
		    ;;
		no)
		    mv $TMPDIR/arguments $TMPDIR/dependencies
		    ;;
		*)
		    echo "error: invalid \$CLBUILD_DEPENDENCIES" 1>&2
		    exit 1
	    esac
	fi

	cp $TMPDIR/dependencies "$BASE/.clbuild-resume"

	for project in $(cat $TMPDIR/dependencies); do
	    skipfile="$project"/.clbuild-skip-update
	    if test -f "$skipfile" -a -n "$clbuild_resume"; then
		echo "resume: skipping update of $project"
	    else
		${UPDATE_SCRIPT} ${UPDATE_ARGS} $project
		ln -f -s $(pwd)/${project}*/*.asd "${system_dir}"/
		touch "$skipfile"
	    fi
	done

	link_extra_asds

	rm "$BASE/.clbuild-resume"

	echo "update complete"
	count_systems
        cd ..
}

link_extra_asds() {
    # some (buggy) projects try to hide their .asd files from us:
    ln -sf $source_dir/mcclim/Experimental/freetype/*.asd ${system_dir}/
    ln -sf $source_dir/eclipse/system.lisp ${system_dir}/eclipse.asd
    ln -f -s $source_dir/graphic-forms/src/external-libraries/*/*/*.asd \
	${system_dir}
    ln -sf $source_dir/clg/*/*.asd ${system_dir}
    ln -sf $source_dir/cells-gtk/*/*.asd ${system_dir}

    # also, override uffi:
    ln -sf $source_dir/cffi/uffi-compat/uffi.asd ${system_dir}/
}

help() {
	cat <<EOF
Usage:
  check         check availability of all necessary helper applications

  list [PATTERN]  list all projects, or projects matching PATTERN

  update [--dependencies|--no-dependencies] PROJECT_SPEC
                download/update this project
  update [--resume]
                download/update main projects.  With --resume, consider
                only projects that a previous update run failed to fetch.
  skip PROJECT_NAME
                mark this project as done for the purposes of update --resume

  recompile PROJECT_SPEC compile fasls
  dumpcore PROJECT_SPEC  recompile and dump a core file for faster startup
  build PROJECT_SPEC     update && dumpcore

  diff          show local changes (for all version-controlled projects)
  check-urls    compared installed repository urls agains current locations
  clean-links   remove broken symlinks in systems/
  update-missing  download only projects not present yet
  register-asd PROJECT  add .asd file symlinks for PROJECT

  updatesbcl    download/update SBCL
  buildsbcl [XC_HOST]  download/update and compile SBCL
  world         buildsbcl && build

  clean         delete all compiled object files
  mrproper      delete all downloaded source and fasl files

  slime         run the Superior Lisp Interaction Mode in a fresh Emacs
  lisp          run Lisp in the terminal

  record-dependencies   rebuild dependency information file

For update/recompile/build/dumpcore a PROJECT_SPEC can be used:
  PROJECT1 PROJECT2 PROJECT3...  # only these
  --main-projects                # all in projects file
  --wnpp-projects                # all in wnpp-projects file
  --all-projects                 # both files

Starting applications:

  run APPLICATION   run this application
  run --help        show help for applications

If you do 'world' or 'buildsbcl' then SBCL will be installed in
target/ and used for future commands. If you don't run these commands
(or you remove target/) then clbuild uses the 'sbcl' in your PATH.

For configuration options (including for non-SBCL lisps), see clbuild.conf.

EOF
}

help_run() {
	cat <<EOF
clbuild run APPLICATION [ARGS...]

  run listener      run the McCLIM listener
  run gsharp        run the Gsharp score editor 
  run climacs       run the Climacs text editor
  run closure [HOME_PAGE_URL]   run the CLOSURE web browser
                    (required Debian packages: gif2png,libjpeg-progs)
  run beirc         run the Beirc IRC client
  run climplayer    run the CLIMPlayer music player
                    (required Debian packages: mplayer, fileschanged, fam)
  run demodemo      run some random CLIM examples
  run clim-alerts   run CLIM alerts
  run eclipse [DPY] run the eclipse window manager

  run hunchentoot   run the Hunchentoot web server test
  run webdav DIR    run the CL-WEBDAV server, serving directory DIR
                    (required Debian packages: libssl-dev)

  run parse-xml FILENAME
                    check XML for well-formedness
  run validate-xml FILENAME
                    check XML for validity
  run validate-relax-ng [--compact yes] XML-FILENAME SCHEMA-FILENAME
                    check XML for validity against a Relax NG Schema
  run html-to-xhtml HTML-FILENAME OUTPUT-FILENAME
  run xhtml-to-html XML-FILENAME OUTPUT-FILENAME
                convert between HTML 4 and XHTMl

  run vecto-demo         generate a test image using vecto
  run adw-charting-demo  generate a test image using adw-charting

  run ltk-demo      show a dialog using ltk
EOF
}

check_program() {
    if ! "$1" --help >/dev/null; then
	echo Error: Cannot find a working installation of "$1"
	exit 1
    fi
    echo "found `which $1`"
}

# for programs that don't understand --help, or (like cvs) are stupid enough
# to return a failure code when invoked using a correct --help option... 
check_misdesigned_program() {
    if ! which "$1" >/dev/null; then
	echo Error: Cannot find a working installation of "$1"
	exit 1
    fi
    echo "found `which $1`"
}

check() {
    echo "Checking for helper applications..."
    check_misdesigned_program cvs
    check_program svn
    check_program darcs
    check_program wget
    check_program tar
    check_misdesigned_program curl
    check_misdesigned_program git
    check_misdesigned_program mktemp
    echo "Success: All helper applications found."
	
    echo
    echo "Checking Lisp startup..."
    if ${lisp} $run_options $eval $quit >/dev/null; then
	echo "Success: Lisp starts up using \"$lisp\""
    else
	echo "Error: Cannot run Lisp using \"$lisp\""
	exit 1
    fi

    echo
    echo "Looking for installable systems..."
    count_systems
}

dumpcore() {
    rm -f "$BASE"/.core-is-stale
    rm -f "$BASE"/monster.core
    recompile --dump "$@"
}

updatesbcl() {
    cd ${source_dir}
    $SBCL_DOWNLOAD_COMMAND
    # Enable threads
    if test -z "$windowsp"; then
	ctf=sbcl/customize-target-features.lisp
	if test -f $ctf; then
	    echo $ctf already exists
	else
	    echo creating $ctf
	    echo '(lambda (list) (pushnew :sb-thread list) list)' >$ctf
	fi
    fi
}

if test -f "$BASE"/monster.core; then
    if test -f "$BASE/.core-is-stale"; then
	echo "using $BASE/monster.core"
	echo 'note: "clbuild update" was used since core file creation'
	echo 'note: consider re-running dumpcore'
    fi
    run_options="$core_option "$BASE"/monster.core $run_options"
fi

scan_projects() {
    cat $1 | awk '{print $1;}' | while read name; do
	if test -n "$name" -a x"$name" != 'x#'; then
	    echo -n "$name "
	fi
    done
}

main_projects=`scan_projects "$BASE/projects"`
wnpp_projects=`scan_projects "$BASE/wnpp-projects"`
all_projects="$main_projects $wnpp_projects"

list() {
    pattern="$1"

    TMPDIR=`mktemp -d /tmp/clbuild.XXXXXXXXXX`
    export TMPDIR
    
    cleanup() {
        rm -rf $TMPDIR
    }
    trap cleanup exit

    cat "$BASE/projects" "$BASE/wnpp-projects" | sort | grep -i -E "$pattern" | while read project rest; do
	if test -n "$project" -a x"$project" != 'x#'; then
	    description=`echo $rest | cut -d\# -f2`
	    case `cd $source_dir && ${UPDATE_SCRIPT} --dry-run $project | cut -d: -f1` in
		MISSING)
		    status=u
		    ;;
		MISMATCH)
		    status="!"
		    ;;
		OK)
		    status="i"
		    ;;
		*)
		    echo "failed to check URL" 1>&2
		    ;;
	    esac

	    echo "$status $project" >>$TMPDIR/left
	    echo $description >>$TMPDIR/right
	fi
    done
    paste $TMPDIR/left $TMPDIR/right | expand -t 25
    exit 0
}

ensure_clppcre() {
    if ! test -d "$source_dir/cl-ppcre"; then
	(
	    cd "$source_dir"
	    update_project cl-ppcre
	    ln -f -s $source_dir/cl-ppcre/*.asd "${system_dir}"/
	)
    fi
}

case $1 in
    check)
	check
	;;
    list)
	list "${2:-.*}"
	;;
    world)
	"$0" clean && "$0" buildsbcl && "$0" build
	;;
    clean)
	rm -f "$BASE"/monster.core
	cd $source_dir
	find . -name "*.fasl" -exec rm {} \;
	find . -name "*.lx64fsl" -exec rm {} \;
	;;
    mrproper)
	rm -rf "$BASE"/monster.core ${source_dir} ${target_dir} ${system_dir}/*
	;;
    skip)
	touch "$source_dir/$2/.clbuild-skip-update"
	;;
    update)
	unset clbuild_resume
	unset extra
	while test -n "$2"; do
	    case "$2" in
		--no-dependencies)
		    CLBUILD_DEPENDENCIES="no"
		    shift
		    ;;
		--dependencies)
		    CLBUILD_DEPENDENCIES="yes"
		    shift
		    ;;
		--resume)
		    clbuild_resume="yes"
		    shift
		    ;;
		--main-projects)
		    extra="$extra $main_projects"
		    shift
		    ;;
		--wnpp-projects)
		    extra="$extra $wnpp_projects"
		    shift
		    ;;
		--all-projects)
		    extra="$extra $all_projects"
		    shift
		    ;;
		*)
		    break
		    ;;
	    esac
	done
	export clbuild_resume
	export CLBUILD_DEPENDENCIES
	shift
	update "$@" $extra
	;;
    update-missing)
	for project in ${2:-$main_projects}; do
	    if ! test -d "${source_dir}/$project"; then
		update $project
	    fi
	done
	;;
    recompile|build|dumpcore)
	operation="$1"
	shift
	unset projects
	while test -n "$1"; do
	    case "$1" in
		--main-projects)
		    projects="$projects $main_projects"
		    shift
		    ;;
		--wnpp-projects)
		    projects="$projects $wnpp_projects"
		    shift
		    ;;
		--all-projects)
		    projects="$projects $all_projects"
		    shift
		    ;;
		*)
		    break
		    ;;
	    esac
	done
	if test -z "$projects" -a $# -eq 0; then
	    exec 1>&2
	    echo "Error: arguments expected"
	    echo "Usage:"
	    echo "  clbuild $operation PROJECT1 PROJECT2 PROJECT3...  # only these"
	    echo "  clbuild $operation --main-projects     # all in projects file"
	    echo "  clbuild $operation --wnpp-projects     # all in wnpp-projects file"
	    echo "  clbuild $operation --all-projects      # both files"
	    exit 1
	fi
	ensure_clppcre
	case $operation in
	    recompile)
		recompile "$@" $projects
		;;
	    build)
		update "$@" $projects
		dumpcore "$@" $projects
		;;
	    dumpcore)
		dumpcore "$@" $projects
		;;
	esac
	;;
    updatesbcl)
	updatesbcl
	;;
    buildsbcl)
        if [ -n "$CCL" ]; then
            echo "Cowardly refusing to build SBCL when \$CCL is set." 1>&2
            exit 1
        fi
	updatesbcl
	(cd sbcl; sh make.sh "$2"; SBCL_HOME= INSTALL_ROOT=${target_dir} sh install.sh)
	;;
    lisp)
	shift;
        clbuild_lisp "$@"
        ;;
    slime)
	shift
	emacs_args="$@"
	emacs=${EMACS-emacs}
	$emacs \
	    -eval "(setq load-path (cons \"${source_namestring}slime\" load-path))" \
	    -eval "(setq load-path (cons \"${source_namestring}slime/contrib\" load-path))" \
	    -eval "(setq inhibit-splash-screen t)" \
	    -eval "(load \"${source_namestring}slime/slime\")" \
	    -eval "(setq inferior-lisp-program \"$self lisp\")" \
	    -eval "(setq slime-use-autodoc-mode nil)" \
            -eval "(slime-setup '(slime-fancy slime-tramp slime-asdf))" \
	    -eval '(slime)' \
	    ${emacs_args}
	;;
    run)
	shift
	case $1 in
	    --help)
		help_run
		exit 0
		;;
	    climplayer)
		check_program fileschanged
		check_misdesigned_program mplayer
		;;
	    hunchentoot|webdav)
		if ! test -f /usr/lib/libssl.so; then
		    echo "WARNING: /usr/lib/libssl.so not found, did you install OpenSSL?"
		    echo "(type RET to continue anyway)"
		    read
		fi
		;;
	esac
	start_application "$@"
	;;
    record-dependencies)
	cd "$BASE"
	for project in $all_projects; do
	    if ! test -d "${source_dir}/$project"; then
		update $project
	    fi
	done
	start_application record-dependencies "$all_projects"
	;;
    check-urls)
	cd "$source_dir"
	for project in ${2:-$all_projects}; do
	    ${UPDATE_SCRIPT} --dry-run $project
	done
	;;
    clean-links)
	cd "$system_dir"
	for f in *; do
	    if test -h "$f"; then
		link_target=`readlink "$f"`
		if ! test -e "$link_target"; then
		    echo "removing broken link from $f to $link_target"
		    rm "$f"
		fi
	    fi
	done
	;;
    register-asd)
	project="$2"
	dir="$source_dir/$project"

	if test -z "$project"; then
	    echo "usage: clbuild register-asd PROJECT" 1>&2
	    exit 1
	fi
	if ! test -d "$dir"; then
	    echo "cannot find $dir" 1>&2
	    exit 1
	fi
	for f in $dir/*.asd; do
	    if test -f "$f"; then
		echo "$f"
		ln -f -s $f "${system_dir}"/
	    fi
	done
	link_extra_asds
	count_systems
	;;
    diff)
	diff="${source_dir}/.diff"
	cp /dev/null "$diff"
	cd "${source_dir}"
	darcs diff -u >>"$diff"
	set +e
	for f in *; do
	    g="${source_dir}/$f"
	    if test -d "$g"; then
		cd "$g"
		echo -n diffing $f... 1>&2
		if test -d CVS; then
		    cvs diff -u 2>/dev/null | grep -v '^?' >>"$diff"
		elif test -d .svn; then
		    svn diff >>"$diff"
		elif test -d '{arch}'; then
		    baz diff >>"$diff"
		elif test -d _darcs; then
		    darcs diff -u >>"$diff"
		elif test -d .git; then
		    git diff >>"$diff"
		else
		    echo -n " FAILED" 1>&2
		fi
		echo 1>&2
	    fi
	done
	less "$diff"
	;;
    help|--long-help|-H|""|--help|-h)
	case $2 in
	    run)
		help_run
		;;
	    *)
		help
	esac
	;;
    *)
	echo "invalid command $1, try --help for help"
	exit 1
esac

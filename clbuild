#!/bin/bash
#
# Script to update/install the latest versions of all the most
# important Common Lisp projects. Uses SBCL but otherwise tries to be
# somewhat independent of your local environment.
#
# Intended to quickly bootstrap a working development environment for
# Lisp free software hackers.
#
# Idea from jhbuild by James Henstridge (a Gnome hacker).
#
# Contributors:
#   Luke Gorrie <luke@member.fsf.org>
#   Anthony Chaumas-Pellet <achaumas@wispery.info>
#   Christophe Rhodes <csr21@cantab.net>
#   David Lichteblau <david@lichteblau.com>
#   Eric Marsden <eric.marsden@free.fr>
#   Andreas Fuchs <asf@boinkor.net>

set -e

if [ "$CLNET_USER" == "" ]; then
    CLNET_USER=:pserver:anonymous:anonymous
fi
export CLNET_USER

if [ "SF_USER" == "" ]; then
    SF_USER=:pserver:anonymous:
fi
export SF_USER

self="$0"
while test -h "$self"; do
	self=`readlink "$self"`
done
BASE="$(cd "$(dirname $self)" && pwd)"
system_dir="$BASE/systems"
source_dir="$BASE/source"
target_dir="$BASE/target"

if test x`uname -o 2>/dev/null` = xCygwin; then
	windowsp=1
else
	windowsp=""
fi

source "$BASE/clbuild.conf.default"
if test -f "$BASE/clbuild.conf"; then
    source "$BASE/clbuild.conf"
fi
# Fix up pathnames
make_absolute_pn() {
	if [ -n "$1" ] ; then
		(cd "$BASE"
		echo "$(cd "$(dirname "$1")" ; pwd)/$(basename "$1")")
	fi
}
case $UPDATE_SCRIPT in
    update_project)
	# okay, new name
	;;
    update.sh)
	# old name
	UPDATE_SCRIPT=update_project
	;;
    *)
	# do will still want this?
	UPDATE_SCRIPT="$(make_absolute_pn "$UPDATE_SCRIPT")"
	;;
esac
USER_INIT="$(make_absolute_pn "$USER_INIT")"

if test -n "$windowsp" -a x$USER_INIT = x/dev/null; then
	USER_INIT=NUL
fi

# CLIM configuration
case x$CLIM_BACKEND in
    xgraphic-forms|xgtkairo|xbeagle)
        EXTRA_CLIM_FEATURES="(pushnew :clim-$CLIM_BACKEND *features*)"
	maybe_load_clx="nil"
        ;;
    x|xclx)
        EXTRA_CLIM_FEATURES="nil"
	maybe_load_clx="(unless (find-package :xlib) (asdf:operate 'asdf:load-op :clx))"
        ;;
    *)
        echo "invalid $CLIM_BACKEND, see clbuild.conf.default for examples." 1>&2
        exit 1
        ;;
esac

if test -n "$windowsp"; then
	system_namestring="`cygpath -m $system_dir`/"
	source_namestring="`cygpath -m $source_dir`/"
	target_namestring="`cygpath -m $target_dir`/"
	self="c:/cygwin/bin/bash $self"
else
	system_namestring="$system_dir/"
	source_namestring="$source_dir/"
	target_namestring="$target_dir/"
fi
set_central_registry="(setq asdf:*central-registry* '(#p\"${system_namestring}\"))"

if [ ! -z $CCL ]; then
    #
    # OpenMCL
    #
    lisp=$CCL

    noinform="-Q"
    end_toplevel_options="" #fixme
    quit="(ccl:quit)"
    eval="--eval"
    require_asdf="(require :asdf)"
    core_option="-I"

    if test x"$USER_INIT" = x/dev/null; then
	# -l /dev/null does not work
	common_options="-n"
    elif test -n "$USER_INIT"; then
	common_options="-n -l $USER_INIT"
    else
	common_options=""
    fi

    # fixme: this doesn't quite match the SBCL version yet:
    build_options="$noinform --batch $common_options"
    run_options="--batch $common_options"
elif [ ! -z $CLISP ]; then
    #
    # CLISP
    #
    echo '*** Using CLISP.  Please note that CLISP support is not complete.'
    lisp="$CLISP -repl"

    noinform="" #fixme
    end_toplevel_options="" #fixme
    quit="(ext:quit)"
    eval="-x"
    require_asdf="(load \"$BASE/source/asdf-for-clisp/asdf.lisp\")"
    core_option="-M"

    if test -n "$USER_INIT"; then
	common_options="-norc -i $USER_INIT"
    else
	common_options=""
    fi

    build_options="-on-error exit $common_options"
    run_options="-on-error exit $common_options"

    if test -d "$BASE/source/asdf-for-clisp"; then
	echo "*** asdf checkout found"
	echo
    else
	echo "NEW checking out asdf for use with clisp"
	(cd "$BASE/source" && cvs -d ${SF_USER}@sbcl.cvs.sourceforge.net:/cvsroot/sbcl co -d asdf-for-clisp sbcl/contrib/asdf)
    fi
else
    #
    # SBCL
    #
    if [ ! -z "$SBCL" ]; then
	lisp=$SBCL
    elif [ -x ${target_dir}/bin/sbcl ]; then
	export SBCL_HOME=${target_namestring}lib/sbcl/
	lisp="${target_dir}/bin/sbcl"
	if ! test -f "$BASE"/monster.core; then
	    lisp="$lisp --core ${target_namestring}lib/sbcl/sbcl.core"
	fi
    else
	lisp=sbcl
    fi

    noinform="--noinform"
    end_toplevel_options="--end-toplevel-options"
    quit="(sb-ext:quit)"
    eval="--eval"
    require_asdf="(require :asdf)"
    core_option="--core"

    if test -n "$USER_INIT"; then
	common_options="--userinit $USER_INIT"
    else
	common_options=""
    fi

    build_options="$noinform --noprint --disable-debugger $common_options"
    run_options="--disable-debugger $common_options"
fi

[ -d "$system_dir" ] || mkdir "$system_dir"
[ -d "$source_dir" ] || mkdir "$source_dir"
[ -d "$target_dir" ] || mkdir "$target_dir"

clbuild_lisp() {
    ${lisp} $common_options \
	$eval "$require_asdf" \
	$eval "$set_central_registry" \
	$eval "$EXTRA_CLIM_FEATURES" \
	"$@"
}

lisp_trampoline() {
    # Start the Lisp with user arguments.  For SBCL, we can do that using
    # --end-toplevel-options.  For other Lisps, go through a temporary
    # file.

    options="$1"
    shift

    if test -n "$end_toplevel_options"; then
	${lisp} \
	    $options \
	    $eval "$require_asdf" \
	    $eval "$set_central_registry" \
	    $eval "$EXTRA_CLIM_FEATURES" \
	    $eval "(load \"$BASE/clbuild.lisp\")" \
	    $end_toplevel_options \
	    "$@"
    else
        TMPDIR=`mktemp -d /tmp/clbuild.XXXXXXXXXX`
	export TMPDIR

        cleanup() {
            rm -rf $TMPDIR
        }
        trap cleanup exit

	while test -n "$1"; do
	    # fixme: whitespacea
	    echo $1 >>$TMPDIR/args
	    shift
	done

	${lisp} \
	    $options \
	    $eval "$require_asdf" \
	    $eval "$set_central_registry" \
	    $eval "$EXTRA_CLIM_FEATURES" \
	    $eval "(defparameter cl-user::*clbuild-args* \"$TMPDIR/args\")" \
	    $eval "(load \"$BASE/clbuild.lisp\")"
    fi
}

start_application() {
    lisp_trampoline "$noinform $run_options" "$@"
}

recompile() {
	rm -f "$BASE"/monster.core
	touch "$source_dir/eclipse/config.lisp"

	if test x"$1" = x--dump; then
	    dump="--dump t"
	    shift
	else
	    dump=""
	fi

	concatenated_args="$@"
	if test -z "$concatenated_args"; then
	    concatenated_args="$main_projects"
	fi

	cd "$BASE"
	lisp_trampoline "$build_options" \
	    recompile-systems \
	    $dump \
	    "$concatenated_args"
}

count_systems() {
	n_asd=`ls -1 "$system_dir"/*.asd | wc -l`
	echo "$n_asd system definition files registered"
}

blank_line="                                                                  "
tail_last() {
    if tty 0>&1 >/dev/null; then
	while read line; do
	    echo -e '\r\c'
	    echo -n "$blank_line"
	    echo -e '\r\c'
	    echo -n $line | cut -b 1-65 | tr -d '\n'
	done
	echo -e '\r\c'
	echo -n "$blank_line"
	echo -e '\r\c'
    else
	while read line; do
	    echo $line
	done
    fi
}

dribble_get() {
    label="$1"
    name="$2"

    if test -d `echo ${name}*/ | awk '{print $1;}'`; then
	echo -n "UPDATE "
    else
	echo -n "NEW "
    fi
    echo "$label $name"
}

dry_run_ok() {
   if test -n "$dry_run"; then
       echo "OK: $1"
   fi
}

dry_run_missing() {
   if test -n "$dry_run"; then
       echo "MISSING: $1"
   fi
}

get_darcs() {
    name="$1"
    url="$2"

    if [ -d $name ]; then
	actual="`cat $name/_darcs/prefs/defaultrepo`"
	if test "x$actual" = "x$url"; then
	    dry_run_ok $1
	else
	    echo "MISMATCH: $1 was installed from $actual, current is $url"
	fi
    else
	dry_run_missing $1
    fi
    if test -n "$dry_run"; then
	exit 0
    fi

    # don't use tail_last, since darcs already has this kind of progress bar
    if [ -d $name ]; then
	dribble_get "darcs pull" $name
	(
	    cd $name
	    if ! test -d _darcs; then
		echo ERROR: not a darcs repository
		exit 1
	    fi
	    darcs pull --all
	    )
    else
	dribble_get "darcs get" $name
	darcs get $url $name
    fi
}

get_git() {
    name="$1"
    url="$2"

    if [ -d $name ]; then
	actual="`cd $name && git config --get remote.origin.url`"
	if test "x$actual" = "x$url"; then
	    dry_run_ok $1
	else
	    echo "MISMATCH: $1 was installed from $actual, current is $url"
	fi
    else
	dry_run_missing $1
    fi
    if test -n "$dry_run"; then
	exit 0
    fi

    if [ -d $name ]; then
	dribble_get "git pull" $name
	(
	    cd $name
	    if ! test -d .git; then
		echo ERROR: not a darcs repository
		exit 1
	    fi
	    git pull
	    )
    else
	dribble_get "git clone" $name
	git clone $url $name
    fi
}

get_svn() {
    name="$1"
    url="$2"

    if [ -d $name ]; then
	actual="`cd $name && svn info | grep ^URL: | awk '{print $2;}'`"
	if test "x$actual" = "x$url"; then
	    dry_run_ok $1
	else
	    echo "MISMATCH: $1 was installed from $actual, current is $url"
	fi
    else
	dry_run_missing $1
    fi
    if test -n "$dry_run"; then
	exit 0
    fi

    dribble_get "svn co" $name

    svn co $url $name | tail_last
}

get_cvs_aux() {
    module="$1"
    repository="$2"
    target_directory="$3"

    if [ -d $module ]; then
	actual="`cat $module/CVS/Root`"
	if test "x$actual" = "x$repository"; then
	    dry_run_ok $1
	else
	    echo "MISMATCH: $1 was installed from $actual, current is $repository"
	fi
    else
	dry_run_missing $1
    fi
    if test -n "$dry_run"; then
	exit 0
    fi

    dribble_get "cvs co" $module

    cvs -d $repository co ${3+-d "$3"} $module | tail_last
}

get_cvs_full() {
    get_cvs_aux $3 $2 $1
}

get_tarball() {
    name="$1"
    url="$2"
    flags="${3:-z}"

    echo "Warning: Using deprecated method get_tarball."

    if test -n "$dry_run"; then
	if ls -d ${name}* >/dev/null; then
	    directories="`ls -d ${name}*`"
	    echo "TARBALL: $directories installed from a tarball, cannot check"
	else
	    dry_run_missing $1
	fi
	exit 0
    fi

    tmp=$TMPDIR/${name}.tar.gz

    dribble_get wget $name

    # We used to delete old directories completely here.  Unfortunately,
    # that can easily lead to loss of changes, a problem all the VC checkout
    # method do not have to the extent.  Save all old data instead.  Users
    # can delete the resulting backup directories easily enough themselves.
    if ls ${name}* >/dev/null; then
	echo got here
	backup=`mktemp -d backup_${name}_XXXXXXXXXX`
	mv ${name}* "$backup/"
    fi
    wget \
	--no-check-certificate \
	--progress=dot \
	-O "$tmp" \
	$url \
	2>&1 | tail_last
    tar v${flags}xf "$tmp" | tail_last
    rm "$tmp"
}

get_svn_clnet() {
    name="$1"
    path="$2"

    get_svn $name svn://common-lisp.net/project/$name/svn/$2
}

get_cvs_clnet() {
    module="$1"
    project="${2:-$1}"

    get_cvs_aux $module ${CLNET_USER}@common-lisp.net:/project/$project/cvsroot
}

get_ediware() {
    get_darcs $1 http://common-lisp.net/~loliveira/ediware/$1
}

get_clbuild_mirror() {
    get_darcs $1 http://common-lisp.net/project/clbuild/mirror/$1
}

get_lichteblau_com() {
    get_git $1 http://www.lichteblau.com/git/$1.git
}

get_b9_com() {
    get_git $1 http://git.b9.com/$1.git
}

get_xach_com() {
    get_git $1 http://git.xach.com/$1.git
}

get_tarball_bz2() {
    get_tarball "$1" "$2" j
}

update_project() {
    if test x$1 = x--dry-run; then
	shift
	dry_run=1
    else
	unset dry_run
    fi
    export dry_run

    if test $# -ne 1; then
	exec 1>&2
	echo error: invalid number of arguments
	echo usage: ... update [--dry-run] PROJECT_NAME
	exit 1
    fi

    if ! grep -h "^$1 " "$BASE/projects" "$BASE/wnpp-projects" >/dev/null; then
       echo Error: cannot download unknown project $1
       exit 1
    fi
    found=`grep -h "^$1 " "$BASE/projects" "$BASE/wnpp-projects" | cut -d\# -f1`
    update_project_2 $found
}

update_project_2() {
    name="$1"
    action="$2"
    shift
    shift
    ( $action $name "$@" )
}

update() {
    # fixme: common dependencies will be processed several times here.
    # This loop needs to be done in update_1 directly.
    if test $# -gt 0; then
	for project in $*; do
	    update_1 $project
	done
    else
	update_1
    fi
}

update_1() {
	rm -f "$BASE"/monster.core

        TMPDIR=`mktemp -d /tmp/clbuild.XXXXXXXXXX`
	export TMPDIR

        cleanup() {
            rm -rf $TMPDIR
        }
        trap cleanup exit

	cd "$source_dir"

	projects="$main_projects"
	if test -n "$1"; then
	    case "$CLBUILD_DEPENDENCIES" in
		yes|ask)
		    if grep "^$1 " ../dependencies >/dev/null; then
			found=`grep "^$1 " ../dependencies`
			if test $CLBUILD_DEPENDENCIES = ask; then
			    echo "$1 depends on: $found"
			    echo -n "include dependencies in update? (Y/n)"
			    read reply
			    case _"$reply" in
				_Y|_y|_)
				    projects="$found"
				    ;;
				_n)
				    projects="$1"
				    ;;
				*)
				    echo Invalid reply
				    exit 1
				    ;;
			    esac
			else
			    projects="$found"
			fi
		    else
			echo "warning: no dependencies for $1 found" 1>&2
			projects="$1"
		    fi
		    ;;
		no)
		    projects="$1"
		    ;;
		*)
		    echo "error: invalid \$CLBUILD_DEPENDENCIES" 1>&2
		    exit 1
	    esac
	elif test -z "$clbuild_resume"; then
	    rm -f */.clbuild-skip-update
	fi

	for project in $projects; do
	    skipfile="$project"/.clbuild-skip-update
	    if test -f "$skipfile" -a -n "$clbuild_resume"; then
		echo "resume: skipping update of $project"
	    else
		${UPDATE_SCRIPT} ${UPDATE_ARGS} $project
		ln -f -s $(pwd)/${project}*/*.asd "${system_dir}"/
		touch "$skipfile"
	    fi
	done

	# some .asd files are hidden:
	ln -sf $(pwd)/mcclim/Experimental/freetype/*.asd ${system_dir}/
	ln -sf $(pwd)/eclipse/system.lisp ${system_dir}/eclipse.asd
	ln -sf $(pwd)/cffi/uffi-compat/uffi.asd ${system_dir}/
	ln -f -s $(pwd)/graphic-forms/src/external-libraries/*/*/*.asd \
	    ${system_dir}

	echo "update complete"
	count_systems
        cd ..
}

help() {
	cat <<EOF
Short usage:

  update [PROJECT] download/update project or all projects
  buildsbcl        download/update and compile SBCL
  build            update, rebuild all applications, and dump a core file
  diff             show local changes (for all version-controlled projects)
  clean            delete all compiled object files
 
  slime            run the Superior Lisp Interaction Mode in a fresh Emacs
  lisp             run Lisp in the terminal
 
  listener         run the McCLIM listener
  hunchentoot      run the Hunchentoot web server test
 
  dialog           show an interactive menu - requires dialog(1)

See also:

  help             show complete usage information

EOF
}

long_help() {
	cat <<EOF
Usage:
  check         check availability of all necessary helper applications

  list [PATTERN]  list all projects, or projects matching PATTERN

  update [--dependencies|--no-dependencies] PROJECT_NAME
                download/update this project
  update [--resume]
                download/update main projects.  With --resume, consider
                only projects that a previous update run failed to fetch.
  skip PROJECT_NAME
                mark this project as done for the purposes of update --resume

  recompile [PROJECT_NAME] recompile main applications (or just PROJECT_NAME)
  dumpcore [PROJECT_NAME]  recompile and dump a core file for faster startup
  build [PROJECT_NAME]     update && dumpcore

  diff          show local changes (for all version-controlled projects)
  check-urls    compared installed repository urls agains current locations
  clean-links   remove broken symlinks in systems/
  update-missing  download only projects not present yet

  buildsbcl [XC_HOST]  download/update and compile SBCL
  world         buildsbcl && build

  clean         delete all compiled object files
  mrproper      delete all downloaded source and fasl files

  slime         run the Superior Lisp Interaction Mode in a fresh Emacs
  lisp          run Lisp in the terminal
  sbcl          alias for "lisp" (with all systems available to REQUIRE)
  openmcl       alias for "lisp"

  listener      run the McCLIM listener
  gsharp        run the Gsharp score editor 
  climacs       run the Climacs text editor
  closure [HOME_PAGE_URL]   run the CLOSURE web browser
                (required Debian packages: gif2png,libjpeg-progs)
  beirc         run the Beirc IRC client
  climplayer    run the CLIMPlayer music player
                (required Debian packages: mplayer, fileschanged, fam)
  demodemo      run some random CLIM examples
  clim-alerts   run CLIM alerts
  eclipse [DPY] run the eclipse window manager

  hunchentoot   run the Hunchentoot web server test
  webdav DIR    run the CL-WEBDAV server, serving directory DIR
                (required Debian packages: libssl-dev)

  parse-xml FILENAME
                check XML for well-formedness
  validate-xml FILENAME
                check XML for validity
  validate-relax-ng [--compact yes] XML-FILENAME SCHEMA-FILENAME
                check XML for validity against a Relax NG Schema
  html-to-xhtml HTML-FILENAME OUTPUT-FILENAME
  xhtml-to-html XML-FILENAME OUTPUT-FILENAME
                convert between HTML 4 and XHTMl

  dialog        show an interactive menu 

Maintainance commands for developers:

  record-dependencies
                rebuild dependency information file

If you do 'world' or 'buildsbcl' then SBCL will be installed in
target/ and used for future commands. If you don't run these commands
(or you remove target/) then clbuild uses the 'sbcl' in your PATH.

For configuration options (including for non-SBCL lisps), see clbuild.conf.

EOF
}

check_program() {
    if ! "$1" --help >/dev/null; then
	echo Error: Cannot find a working installation of "$1"
	exit 1
    fi
    echo "found `which $1`"
}

# for programs that don't understand --help, or (like cvs) are stupid enough
# to return a failure code when invoked using a correct --help option... 
check_misdesigned_program() {
    if ! which "$1" >/dev/null; then
	echo Error: Cannot find a working installation of "$1"
	exit 1
    fi
    echo "found `which $1`"
}

interactive_menu() {
    if ! dialog --clear --title "clbuild" \
	--menu "Welcome to clbuild's interactive menu.\n\n\
If unsure, choose 'update' to download the userland, then try\n\
running one of applications." \
	0 0 0 \
	"update" "download/update all applications" \
	"recompile" "recompile all applications" \
	"dumpcore" "recompile and dump a core file for faster startup" \
	"" "" \
	"buildsbcl" "download/update and compile SBCL" \
	"world" "buildsbcl && update && dumpcore" \
	"" "" \
	"slime" "run the Superior Lisp Interaction Mode in a fresh Emacs" \
	"slime -nw" "run the Superior Lisp Interaction Mode (in this TTY)" \
	"lisp" "run Lisp in the terminal" \
	"" "" \
	"gsharp" "run the Gsharp score editor" \
	"climacs" "run the Climacs text editor" \
	"closure" "run the CLOSURE web browser" \
	"beirc" "run the Beirc IRC client" \
	"climplayer" "run the CLIMPlayer music player" \
	"demodemo" "run some random CLIM examples" \
	"hunchentoot" "run the Hunchentoot web server test" \
	"webdav" "run the CL-WEBDAV server" \
	"eclipse" "run the eclipse window manager" \
	"" "" \
	"clear" "Delete all fasls" \
	"mrproper" "Delete all downloaded source and fasls" \
	"" "" \
	"quit" "Exit clbuild" \
	2>$TMPDIR/choice
    then
	echo menu aborted
	exit 0
    fi
    choice="`cat $TMPDIR/choice`"
    case $choice in
	webdav)
	    if dialog --title "clbuild webdav" --clear --inputbox \
		"A WebDAV server will be started on http://localhost:4242.\n\n\
Files will be served for read and write operations without authentication.\n\n\
Please choose a directory to be exported." \
		16 72 /tmp 2>$TMPDIR/choice
	    then
		directory=`cat $TMPDIR/choice`
		if test -d $directory; then
		    choice="webdav $directory"
		else
		    $DIALOG --title "clbuild webdav" --clear \
			--msgbox "Error: Directory not found: $directory" \
			10 41
		    choice=""
		fi
	    else
		choice=""
	    fi
	    ;;
	eclipse)
	    if dialog --title "clbuild webdav" --clear --inputbox \
		"Please enter the X11 display to run eclipse on." \
		16 72 ${DISPLAY:-:0} 2>$TMPDIR/choice
	    then
		choice="eclipse `cat $TMPDIR/choice`"
	    else
		choice=""
	    fi
	    ;;
    esac
    case $choice in
	"")
	    ;;
	quit)
	    exit 0
	    ;;
	*)
	    echo
	    "$0" $choice || echo clbuild: $choice failed
	    echo
	    echo Type RET to continue
	    read
	    ;;
    esac
}

check() {
    echo "Checking for helper applications..."
    check_misdesigned_program cvs
    check_program svn
    check_program darcs
    check_program wget
    check_program tar
    check_misdesigned_program git
    check_misdesigned_program mktemp
    echo "Success: All helper applications found."
	
    echo
    echo "Checking Lisp startup..."
    if ${lisp} $run_options $eval $quit >/dev/null; then
	echo "Success: Lisp starts up using \"$lisp\""
    else
	echo "Error: Cannot run Lisp using \"$lisp\""
	exit 1
    fi

    echo
    echo "Looking for installable systems..."
    count_systems
}

dumpcore() {
    recompile --dump "$@"
}

if test -f "$BASE"/monster.core; then
    # echo "using `pwd`/monster.core"
    run_options="$core_option "$BASE"/monster.core $run_options"
fi

scan_projects() {
    cat $1 | awk '{print $1;}' | while read name; do
	if test -n "$name" -a x"$name" != 'x#'; then
	    echo -n "$name "
	fi
    done
}

main_projects=`scan_projects "$BASE/projects"`
all_projects=$main_projects\ `scan_projects "$BASE/wnpp-projects"`

list_file() {
    file="$1"
    pattern="$2"
    category="$3"

}

list() {
    pattern="$1"
    cat "$BASE/projects" "$BASE/wnpp-projects" | sort | grep -i -E "$pattern" | while read project rest; do
	if test -n "$project" -a x"$project" != 'x#'; then
	    description=`echo $rest | cut -d\# -f2`
	    case `cd $source_dir && ${UPDATE_SCRIPT} --dry-run $project | cut -d: -f1` in
		MISSING)
		    status=u
		    ;;
		MISMATCH)
		    status="!"
		    ;;
		OK)
		    status="i"
		    ;;
		*)
		    echo "failed to check URL" 1>&2
		    ;;
	    esac

	    left="$status $project"
	    count=`echo -n "$left" | wc -c`
	    count=`expr 25 - $count`
	    space=`for x in $(seq 1 $count); do echo -n " "; done`
	    echo "$left$space$description"
	fi
    done
    exit 0
}

case $1 in
    check)
	check
	;;
    list)
	list "${2:-.*}"
	;;
    world)
	"$0" clean && "$0" buildsbcl && "$0" build
	;;
    clean)
	rm -f "$BASE"/monster.core
	cd $source_dir
	find . -name "*.fasl" -exec rm {} \;
	find . -name "*.lx64fsl" -exec rm {} \;
	;;
    mrproper)
	rm -rf "$BASE"/monster.core ${source_dir} ${target_dir}
	;;
    skip)
	touch "$source_dir/$2/.clbuild-skip-update"
	;;
    update)
	unset clbuild_resume
	while test -n "$2"; do
	    case "$2" in
		--no-dependencies)
		    CLBUILD_DEPENDENCIES="no"
		    shift
		    ;;
		--dependencies)
		    CLBUILD_DEPENDENCIES="yes"
		    shift
		    ;;
		--resume)
		    clbuild_resume="yes"
		    shift
		    ;;
		*)
		    break
		    ;;
	    esac
	done
	export clbuild_resume
	export CLBUILD_DEPENDENCIES
	shift
	update "$@"
	;;
    update-missing)
	for project in ${2:-$main_projects}; do
	    if ! test -d "${source_dir}/$project"; then
		update $project
	    fi
	done
	;;
    recompile)
	shift
	recompile "$@"
	;;
    build)
	shift
	update "$@"
	dumpcore "$@"
	;;
    dumpcore)
	shift
	dumpcore "$@"
	;;
    buildsbcl)
        if [ -n "$CCL" ]; then
            echo "Cowardly refusing to build SBCL when \$CCL is set." 1>&2
            exit 1
        fi
	cd ${source_dir}
	cvs -d ${SF_USER}@sbcl.cvs.sourceforge.net:/cvsroot/sbcl co sbcl
	# Enable threads
	if test -z "$windowsp"; then
	    echo '(lambda (list) (pushnew :sb-thread list) list)' > sbcl/customize-target-features.lisp
	fi
	(cd sbcl; sh make.sh "$2"; SBCL_HOME= INSTALL_ROOT=${target_dir} sh install.sh)
	;;
    lisp)
	shift;
        clbuild_lisp "$@"
        ;;
    sbcl)
        if [ -n "$CCL" ]; then
            echo "Cowardly refusing to run SBCL when \$CCL is set." 1>&2
            exit 1
        fi
	shift;
        clbuild_lisp "$@"
	;;
    openmcl)
        if [ -z "$CCL" ]; then
            echo "Cannot run OpenMCL because \$CCL is not set." 1>&2
            exit 1
        fi
	shift;
        clbuild_lisp "$@"
	;;
    slime)
	shift
	emacs_args="$@"
	emacs=${EMACS-emacs}
	$emacs \
	    -eval "(setq load-path (cons \"${source_namestring}slime\" load-path))" \
	    -eval "(setq load-path (cons \"${source_namestring}slime/contrib\" load-path))" \
	    -eval "(setq inhibit-splash-screen t)" \
	    -eval "(load \"${source_namestring}slime/slime\")" \
	    -eval "(setq inferior-lisp-program \"$self lisp\")" \
	    -eval "(setq slime-use-autodoc-mode nil)" \
            -eval "(slime-setup '(slime-fancy slime-tramp slime-asdf))" \
	    -eval '(slime)' \
	    ${emacs_args}
	;;
    listener|gsharp|demodemo|climacs|closure|beirc|parse-xml|validate-xml|validate-relax-ng|html-to-xhtml|xhtml-to-html|clim-alerts|vecto-demo)
	start_application "$@"
	;;
    record-dependencies)
	cd "$BASE"
	start_application record-dependencies "$all_projects"
	;;
    climplayer)
	check_program fileschanged
	check_misdesigned_program mplayer
	start_application "$@"
	;;
    hunchentoot)
	if ! test -f /usr/lib/libssl.so; then
	    echo "WARNING: /usr/lib/libssl.so not found, did you install OpenSSL?"
	    echo "(type RET to continue anyway)"
	    read
	fi
	start_application "$@"
	;;
    webdav)
	if ! test -f /usr/lib/libssl.so; then
	    echo "WARNING: /usr/lib/libssl.so not found, did you install OpenSSL?"
	    echo "(type RET to continue anyway)"
	    read
	fi
	start_application "$@"
	;;
    eclipse)
	touch source/eclipse/config.lisp
	# zzz cl-user::*eclipse-initfile*?!
	# zzz cl-user::*eclipse-eclipsedir*?!
	start_application "$@"
	;;
    check-urls)
	cd "$source_dir"
	for project in ${2:-$all_projects}; do
	    ${UPDATE_SCRIPT} --dry-run $project
	done
	;;
    clean-links)
	cd "$system_dir"
	for f in *; do
	    if test -h "$f"; then
		link_target=`readlink "$f"`
		if ! test -e "$link_target"; then
		    echo "removing broken link from $f to $link_target"
		    rm "$f"
		fi
	    fi
	done
	;;
    diff)
	diff="${source_dir}/.diff"
	cp /dev/null "$diff"
	cd "${source_dir}"
	darcs diff -u >>"$diff"
	set +e
	for f in *; do
	    g="${source_dir}/$f"
	    if test -d "$g"; then
		cd "$g"
		echo -n diffing $f... 1>&2
		if test -d CVS; then
		    cvs diff -u 2>/dev/null | grep -v '^?' >>"$diff"
		elif test -d .svn; then
		    svn diff >>"$diff"
		elif test -d '{arch}'; then
		    baz diff >>"$diff"
		elif test -d _darcs; then
		    darcs diff -u >>"$diff"
		elif test -d .git; then
		    git diff >>"$diff"
		else
		    echo -n " FAILED" 1>&2
		fi
		echo 1>&2
	    fi
	done
	less "$diff"
	;;
    help|--long-help|-H)
        long_help
	;;
    ""|--help|-h)
	help
	;;
    dialog)
        if ! dialog --help >/dev/null; then
	    cat <<EOF

error: dialog(1) not found.  Cannot start interactive menu.
Install dialog or try clbuild --help instead.
EOF
	    exit 1
	fi

	# always run check first to avoid unpleasant surprises
	check


        TMPDIR=`mktemp -d /tmp/clbuild.XXXXXXXXXX`

        cleanup() {
            rm -rf $TMPDIR
        }
        trap cleanup exit

	while :; do
	    interactive_menu
	done
	;;
    *)
        help
	exit 1
esac
